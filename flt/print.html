<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Formal Language Theory for Linguists</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Abstract Structures</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> The Myhill-Nerode Theorem</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Suffix Substitution Closure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Functions and Tails</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Substitutible Languages</div></li><li class="chapter-item expanded affix "><li class="part-title">Logic</li><li class="chapter-item expanded "><a href="fo-intro.html"><strong aria-hidden="true">5.</strong> First Order Logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fo-models.html"><strong aria-hidden="true">5.1.</strong> String models</a></li><li class="chapter-item expanded "><a href="fo-synsem.html"><strong aria-hidden="true">5.2.</strong> Syntax and semantics</a></li><li class="chapter-item expanded "><a href="fo-grammars.html"><strong aria-hidden="true">5.3.</strong> Formulas as grammars</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Representations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Propositional Logic</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Monadic Second Order Logic</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Interpretations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Boolean Monadic Recursive Schemes</div></li><li class="chapter-item expanded affix "><li class="part-title">Automata</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> ...</div></li><li class="chapter-item expanded affix "><li class="part-title">Learning</li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> ...</div></li><li class="chapter-item expanded affix "><a href="bibliography.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Formal Language Theory for Linguists</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this?</a></h2>
<p>This is a collection of notes on formal language theory, mathematical logic, model theory, automata theory, and formal learning theory as they can be applied to linguistics.
They are for graduate students of linguistics and others interested in getting their hands dirty with this kind of work.</p>
<p>My immediate plan for this is to write up my lecture notes from our local Math Ling group at the Rutgers University Department of Linguistics.
I would also love it if others would be willing to contribute chapters on areas of their expertise.
The idea for this is to be an easy-to-access collection of knowledge related to formal-language-theoretic linguistics.</p>
<p>Please let me know if you have any thoughts, suggestions, or something to contribute at adam.jardine@rutgers.edu.</p>
<p><strong>What lies ahead is a work in progress.</strong> 
Proceed at your own risk.</p>
<h2 id="technical-details"><a class="header" href="#technical-details">Technical details</a></h2>
<p>This was written using <a href="https://rust-lang.github.io/mdBook/index.html">mdbook</a> (hats off to <a href="https://www.nickdanis.com/">Nick Danis</a> for introducing it to me) and is hosted on <a href="https://github.io">GitHub</a>.</p>
<h2 id=""><a class="header" href="#"></a></h2>
<hr />
<p>© 2022 Adam Jardine</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-order-logic-and-the-star-free-languages"><a class="header" href="#first-order-logic-and-the-star-free-languages">First-order Logic and the Star-Free Languages</a></h1>
<h1 id="draft"><a class="header" href="#draft">[DRAFT]</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Last time we learned about the difference between computable and uncomputable languages. 
This time, we're going to show how we can compute languages using <strong>first-order logic (FO)</strong>. </p>
<p>Let's start with an actual natural language pattern.
In Sarcee [<a href="bibliography.html#cook78">cook78</a>], [+anterior] sibilants can follow [-anterior] sibilants, but the reverse results in ungrammaticality. 
(Data from [<a href="bibliography.html#cook78">cook78</a>], cited in [<a href="bibliography.html#heinz10">heinz10</a>]. Sibilants are highlighted in bold.)</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>ʃ</strong>ít<strong>ʃ</strong>íd<strong>z</strong>àʔ</td><td>'my duck'</td></tr>
<tr><td>nā<strong>ʃ</strong>ɣát<strong>ʃ</strong></td><td>'I killed them again'</td></tr>
<tr><td>*<strong>s</strong>ít<strong>ʃ</strong>íd<strong>z</strong>àʔ</td><td></td></tr>
</tbody></table>
</div>
<p>In the above example, the [-anterior] [z] follows the [+anterior] [ʃ], but it is impossible for the [+anterior] [ʃ] to follow [s]. </p>
<p>Let's study this abstractly as a formal language.
Let \(L\) be the formal language over \(\Sigma=\{a,b,c\}\) of all strings such that no \(a\) ever precedes a \(b\), anywhere in the string. I.e.,</p>
<p>\[ L = \{accca,cccc,bcccb,bbccca,...\}\]</p>
<p>and </p>
<p>\[ \overline{L} = \{ab,acccb, ccaccccbc, aacccccccccb, .... \}  \]</p>
<p>Thus, \(L\) above distills the precedence-based constraint in Sarcee, replacing [-anterior] consonants with \(a\) and [+anterior] consonants with \(b\) (and everything else with \(c\)). </p>
<p>We can describe \(L\) with the below FO statement that forbids a \(b\) from following an \(a\). </p>
<p>\[(\forall x)[a(x)\rightarrow\neg(\exists y)[b(y)\land x&lt;y]]\]</p>
<p>For now, we'll forgo the formal details and interpret the statement informally. 
The variables \(x\) and \(y\) here range over <em>positions</em> (or <em>indices</em>) in a string. 
Thus, \(a(x)\) is interpreted to mean 'position \(x\) is occupied by the symbol \(a\).' </p>
<p>The entire statement, then, reads as follows:</p>
<blockquote>
<p>For every position \(x\), if \(x\) is an \(a\), then there is no \(y\) such that \(y\) is a \(b\) and \(x\) precedes \(y\).</p>
</blockquote>
<p>This logical statement thus specifies a constraint on strings: for <em>every</em> \(a\) in a string, it cannot precede a \(b\). 
As shown in detail below, this statement is either true or false for every string in \(\Sigma^*\), and there is a procedure for computing this. 
Thus, this logical statement specifies exactly the strings in \(L\): the strings in \(L\) are those for which the statement is true, and the strings <em>not</em> in \(L\) are those for which it is false.</p>
<p>The advantages of using logical statements as grammars are numerous. 
Among them are the following.</p>
<ul>
<li>
<p>We can draw from a rich literature connecting logic and computation [<a href="bibliography.html#buchi60">buchi60</a>],[<a href="bibliography.html#mcnaughtonpapert71">mcnaughtonpapert71</a>],[<a href="bibliography.html#immerman80">immerman80</a>],[<a href="bibliography.html#rogerspullum11">rogerspullum11</a>]. </p>
<!--   * We can thus connect logical grammars to abstract characterizations like \\(k\\)-suffix substitution closure-->
</li>
<li>
<p>We can study patterns over structures besides strings.</p>
</li>
<li>
<p>They allow us to directly connect formal language classes to classes of <em>functions</em>, through the technique of logical interpretations [<a href="bibliography.html#engelfriethoogeboom01">engelfriethoogeboom01</a>],[<a href="bibliography.html#filiot15">filiot15</a>].</p>
</li>
</ul>
<p>There are more, which we will learn about more later. 
For now, we will use FO as a primer for using logical statements as grammars for languages, and discuss how FO is connected to the <strong>star-free (SF)</strong> class of formal languages [<a href="bibliography.html#mcnaughtonpapert71">mcnaughtonpapert71</a>].</p>
<p>Before we define our logic, we have to define strings in a bit more detail. 
That is, it is necessary to encode all the information that is necessary to identify a particular string. 
To do this we use <strong>model theory</strong>, the mathematical structure of language. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-order-logic-and-the-star-free-languages-1"><a class="header" href="#first-order-logic-and-the-star-free-languages-1">First-order Logic and the Star-Free Languages</a></h1>
<h1 id="draft-1"><a class="header" href="#draft-1">[DRAFT]</a></h1>
<h2 id="string-models"><a class="header" href="#string-models">String models</a></h2>
<p>Before we define our logic, we have to define strings in a bit more detail. 
That is, it is necessary to encode all the information that is necessary to identify a particular string. 
To do this we use <strong>model theory</strong>, the mathematical structure of language. </p>
<p>Continuing to fix our alphabet to \(\Sigma=\{a,b,c\}\), what information do we need to identify a particular string in \(\Sigma^*\) from any other?
The <strong>model</strong> will be a representation of this information.</p>
<p>First, think about the string \(aaaa\) as opposed to \(aaaaaa\). 
What distinguishes the former from the latter, clearly, is that there are four symbols in \(aaaa\) whereas there are six in \(aaaaaa\). 
So we need to distinguish the <em>number</em> of elements in a string. </p>
<p>We do that by establishing a <strong>domain</strong> (also referred to as a <strong>universe</strong>) (D) of elements in the string. 
This is a finite set of objects that represent the elements in our structure. 
By convention, we will use an initial sequence of natural numbers, i.e.
\[D=\{1,2,3,4,...,n\}\]
for some finite \(n\). 
Thus, for example, the domain of the model for \(aaaa\) will be \(\{1,2,3,4\}\) and the domain for the model for \(aaaaaa\) will be \(\{1,2,3,4,5,6\}\). </p>
<p><strong>Note:</strong> While we use numbers, <em>there is no inherent order on these objects</em>. 
We could instead be using symbols like \(\{\square,\triangle,\bigcirc,\diamondsuit\}\). 
But numbers are just easier.</p>
<p>Of course, \(\Sigma^*\) does not only contain strings of all \(a\)s. 
The string \(aaaa\) must also be distinguished from, say \(abaa\). 
So we have to specify the <em>symbols</em> that are associated with elements in the string.
We do this using <strong>relations</strong> on the domain in the model.
A relation \(R\) is a <strong>unary relation</strong> (or <strong>property</strong>) or simply a subset of the domain:
\[R\subseteq D\]</p>
<p>So we can add a unary relation \(R_b\) that indicates which elements are (b)s. 
Thus the model for \(aaaa\) would be 
\[M(aaaa)=\langle D=\{1,2,3,4\}; R_b=\{\}\rangle\]
and the model for \(abaa\) would be 
\[M(abaa)=\langle D=\{1,2,3,4\}; R_b=\{2\}\rangle.\]</p>
<p>We are not yet done though. 
Consider \(abaa\) and \(aaba\). 
These are distinct strings, but their models will be equivalent:
\[M(abaa)=\langle D=\{1,2,3,4\}; R_b=\{2\}\rangle\]
\[M(aaba)=\langle D=\{1,2,3,4\}; R_b=\{3\}\rangle\]
Note that the element in \(R_b\) is different in each of these models, given our numbering scheme, <em>but these elements do not have any inherent order</em>. 
So \(\langle D=\{1,2,3,4\}; R_b=\{3\}\rangle\) is <strong>isomorphic</strong> to \(\langle D=\{1,2,3,4\}; R_b=\{2\}\rangle\). 
That is, <em>given the information available in the model</em>, there is no way to tell the two apart.</p>
<p>So, we add a <strong>binary relation</strong> \(R_&lt;\) that orders the elements in the model.
A binary relation \(R\) consists of pairs of elements in the domain; i.e.
\[R\subseteq D\times D\]</p>
<p>For example, for \(abaa\) we have
\[M(abaa)=\langle D=\{1,2,3,4\}; R_b=\{2\}, R_&lt;=\{(1,2),(2,3),(1,3),(1,4),(2,4),(3,4)\}\rangle\]
and for \(aaba\) we have 
\[M(aaba)=\langle D=\{1,2,3,4\}; R_b=\{3\}, R_&lt;=\{(1,2),(2,3),(1,3),(1,4),(2,4),(3,4)\}\rangle.\]</p>
<p>Now these are different (i.e., non-equivalent) models!
In \(M(abaa)\), the element in \(R_b\) is only preceded by one other element;
in \(M(aaba)\), the element in \(R_b\) is preceded by two. 
So now we have a way to distinguish strings in \(a\)s and \(b\)s, with one relation marking the \(b\)s and an ordering relation on the elements of the domain. </p>
<p>To also capture \(c\)s, we need to add another relation, \(R_c\). 
In fact, for any string signature, it's most straightforward to have a unary relation for each symbol in the alphabet. 
Thus, in this particular case, for any string model we'll need the unary relations \(R_a,R_b,R_c\) and the binary relation \(R_&lt;\). </p>
<p>This set of relations \(R_1,R_2...,R_n\) is called a <strong>signature</strong>. 
We'll use calligraphic capital letters, e.g. \(\mathcal{S}\), to indicate signatures.</p>
<p>The signature we will use to represent strings in an arbitrary finite alphabet \(\Sigma=\{\sigma_1,\sigma_2,...,\sigma_n\}\) is as follows.</p>
<p>\[\mathcal{S}^&lt;=\{R_{\sigma_1},R_{\sigma_2},...,R_{\sigma_n},R_&lt;\}\]</p>
<p>To recap, a (finite) <strong>model</strong> is a mathematical object that lets us describe other objects. 
Formally, it is a tuple consisting of a set of elements or <strong>domain</strong> (or <strong>universe</strong>) \(D\) and a series of relations \(R_1,R_2,..., R_n\) on the domain. </p>
<p>\[\langle D; R_1, R_2, ..., R_n\rangle\]</p>
<p>The name of a particular set of relations that we use to model some set of structures is a <strong>signature</strong>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-order-logic-and-the-star-free-languages-2"><a class="header" href="#first-order-logic-and-the-star-free-languages-2">First-order Logic and the Star-Free Languages</a></h1>
<h1 id="draft-2"><a class="header" href="#draft-2">[DRAFT]</a></h1>
<h2 id="the-syntax-and-semantics-of-first-order-logic"><a class="header" href="#the-syntax-and-semantics-of-first-order-logic">The syntax and semantics of first order logic</a></h2>
<p>Given a signature, we can define a FO logic over that signature. 
To build such a logic and define how it can be interpreted over models in the signature, we need to define the <strong>syntax</strong> and <strong>semantics</strong> of FO.
Defining this precisely tells us not only the range of grammars we can write, but also how these grammars compute languages.</p>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>The syntax defines the range of statements we can write.</p>
<p>First, statements in FO choose from a set of <strong>variables</strong> \(\mathcal{X}=\{x,y,z,...,x_1,x_2,...\}\). </p>
<p>Additionally, for each relation in the signature, we have a set of <strong>atomic formulas</strong> that correspond to the relations in our model (plus equality).</p>
<p><strong>Definition.</strong> (Atomic formulas)</p>
<ol>
<li>For any two variables \(x\) and \(y\), \(x=y\) is an atomic formula. </li>
<li>For any two variables \(x\) and \(y\), \(x&lt;y\) is an atomic formula.</li>
<li>For any variable \(x\) and any unary relation \(R_\sigma\in\mathcal{S}\), \(\sigma(x)\) is an atomic formula.</li>
</ol>
<p>Atomic formulas, as their name suggests, define the basic properties in the model to which the logic refers. 
Given our running example for \(\Sigma={a,b,c}\), some atomic formulas are \(a(x)\), \(b(z)\), \(x=y\), \(y&lt;z\), etc.</p>
<p>The set of <strong>well-formed formulas (WFFs)</strong> in FO is then built out of atomic formulas connected by the logical connectives 
\(\neg\) and \(\lor\) and the quantifier \(\forall\). </p>
<!--\\(\neg, \land, \lor, \rightarrow\\) and the quantifiers \\(\forall, \exists\\).-->
<p><strong>Definition.</strong> (Well-formed formulas) </p>
<ol>
<li>If \(\varphi\) is an atomic formula, then \(\varphi\) is a WFF </li>
<li>If \(\varphi\) is a WFF, then \((\neg\varphi)\) is a WFF <!--* If \\(\varphi\\) and \\(\psi\\) are WFFs, then \\((\varphi\land\psi)\\) are WFFs--></li>
<li>If \(\varphi\) and \(\psi\) are WFFs, then \((\varphi\lor\psi)\) are WFFs <!--* If \\(\varphi\\) and \\(\psi\\) are WFFs, then \\((\varphi\rightarrow\psi)\\) are WFFs--></li>
<li>If \(\varphi\) is a WFF for which \(x\) is a free variable, then \((\forall x)[\varphi]\) is a WFF <!--* If \\(\varphi\\) is a WFF for which \\(x\\) is a free variable, then \\((\exists x)[\varphi]\\) is a WFF--></li>
</ol>
<p>A <strong>free variable</strong> in an formula \(\varphi\) is a variable \(x\) such that \(...x...\) appears in \(\varphi\) without being preceded by \((\forall x)\) or \((\exists x)\) (i.e., it's not <strong>bound</strong> by a quantifier).</p>
<p>Note that this definition is <em>recursive</em>: the definition of WFF itself refers to WFFs. 
Thus, we can write an infinite number of WFFs by recursively applying the rules above.
For example, \((\neg a(x))\) is built by starting with the atomic formula \(a(x)\) and plugging that in as \(\phi\) for rule (2.) in the definition of WFFs. </p>
<blockquote>
<p>Take a moment to convince yourself of how this works by deriving the WFFs \(((\neg a(x))\lor b(x))\) and \((\forall x)[(b(x)\lor(\neg(c(x))))\).</p>
</blockquote>
<p><strong>Some notational sugar.</strong>
The parentheses in the above definition make the composition of a WFF explicit, but they are often removed for readability when there is no danger of ambiguity.
So, for example, \(((\neg a(x))\lor b(x))\) can be rewritten as \(\neg a(x)\lor b(x)\). </p>
<p>Finally, the other common logical connectives \(\rightarrow\) and \(\land\) and the quantifier \(\exists\) can be derived from the syntax we've already defined. 
Namely, </p>
<ul>
<li>\(\varphi\rightarrow\psi := \neg\varphi\lor\psi\)</li>
<li>\(\varphi\land\psi := \neg(\neg\varphi\lor\neg\psi)\)</li>
<li>\((\exists x)[\varphi] := \neg(\forall x)[\neg\varphi]\)</li>
</ul>
<p>...where the notation '\(:=\)' means something like 'can be re-written as'. </p>
<blockquote>
<p>Take a minute apply the above to construct our original example of \((\forall x)[a(x)\rightarrow\neg(\exists y)[b(y)\land x&lt;y]]\). </p>
</blockquote>
<h3 id="semantics"><a class="header" href="#semantics">Semantics</a></h3>
<p>So far our FO WFFs are just strings of meaningless symbols. 
We have to define the semantics of our WFFs; that is, when a WFF is true in a model.
We will do this <em>recursively</em>, following closely the definition above of the syntax of FO logic. 
In this way, for every sentence we can construct using our syntax, our semantics guarantees an interpretation for it.</p>
<p>Because this is a <em>first-order</em> logic, the variables \(x,y,z,\) etc. range over elements of the domain (i.e., positions in the string).
Satisfaction is then dependent on how variables are assigned to positions into the string. 
As such, our notation for satisfaction must take into account this dependency.</p>
<p>Thus, satisfaction will be defined specifying the model \(M\) and some series \(i_1,i_2,...,i_k\) of \(k\) elements in \(D\).
Accordingly, below \(\varphi(x_1,x_2,...,x_k)\) refers to a WFF with exactly \(k\) free variables \(x_1,x_2,...,x_k\). 
Essentially, we are going to plug each \(i_j\) into each variable \(x_j\).</p>
<!--For a model \\(M\\), take a function \\(s:\mathcal{X}\rightarrow D\\) that maps the set of possible FO variables to positions in \\(M\\)'s domain \\(D\\). 
We can then say that the model **satisfies** a WFF \\(\varphi\\) given this mapping, written -->
<p><strong>Definition.</strong> (Satisfaction of well-formed formulas)</p>
<ol>
<li>a. \(M,i\models \sigma(x)\)   iff   \(i\in R_\sigma\)<br />
b. \(M,i,j\models (x&lt;y)\) iff \((i,j)\in R_&lt;\)<br />
c. \(M,i,j\models (x=y)\) iff \(i=j\) (that is, \(i\) and \(j\) are the same element in \(D\).)</li>
<li>\(M,i_1,i_2...,i_k\models \neg\varphi(x_1,x_2...,x_k)\) iff \(M,i_1,i_2,...,i_k\not\models \varphi(x_1,x_2...,x_k)\) (that is, \(M,i_1,i_2,...,i_k\) <em>does not</em> satisfy \(\varphi(x_1,x_2,...,x_k)\)). </li>
<li>\(M,i_1,i_2,...,i_k,j_1,j_2,...,j_\ell\models \varphi(x_1,x_2,...,x_k)\land\psi(y_1,y_2,...,y_\ell)\) iff \(M,i_1,...,i_k\models \varphi(x_1,x_2,...,x_k)\) and \(M,j_1,j_2,...,j_k\models \psi(y_1,y_2,...,y_\ell).\)</li>
<li>\(M,i_1,...,i_k\models (\forall x)[\varphi(x,y_1,y_2,...,y_k)]\) iff for all \(i\in D\), \(M,i,i_1,...,i_k\models\varphi(x,y_1,...,y_k).\)</li>
</ol>
<p>This is a lot, so let us go through each. 
To illustrate, we'll use \(M=M(abac)\), depicted graphically below.</p>
<p>\[
\begin{array}{c}
\begin{array}{|c|c|c|c|}\hline
a &amp; b &amp; a &amp; c \\ \hline
\end{array}\\
\begin{array}{cccc}
1 &amp; 2 &amp; 3 &amp; 4 \\
\end{array}
\end{array}
\]</p>
<p>First, notice that each part of the definition matches with the definition of the syntax of well-formed formulas above.
Thus, for example, part (1) of the definition of the semantics defines the semantics for atomic formulas (i.e., from part (1) of the definition of the syntax).</p>
<p>So if our WFF is simply \(a(x)\), then \(M,1\models a(x)\) because \(1\in R_a\) in \(M\); conversely, \(M,2\not\models a(x)\) because \(2\not\in R_a\) in \(M\).
Similarly, \(M,1,2,3\models(\neg b(x))\land (y&lt;z)\) because \(M,1\models\neg b(x)\) (because \(1\not\in R_b\) and thus \(M,1\not\models b(x)\)) and \(M,2,3\models y&lt;z\) (because \((2,3)\in R_&lt;\)).</p>
<p>Part (4) of the definition, with the quantifier, is a bit different.
Say we have a WFF \((\forall x)[a(y)\land y&lt;x]\). 
Satisfaction here only requires specifying one element in the domain, specifically that which will correspond to \(y\), as \(x\) is bound by a quantifier. 
So let us check whether \(M,1\models(\forall x)[a(y)\land \neg( y&lt;x )]\). </p>
<p>By the definition, \(M,1\models(\forall x)[a(y)\land \neg (x&lt;y)]\) only in the case that for <em>all</em> \(i\in D\),  \(M,i,1\models a(y)\land \neg x&lt;y]\). 
In other words, no matter what element we assign \(x\) to, satisfaction goes through. 
One sure way to calculate this is via brute force, i.e. checking each element in \(D\) to make sure satisfaction holds in every case.<sup class="footnote-reference"><a href="#calc">1</a></sup>
So first we set \(i=1\). 
It holds that \(M,1,1\models a(y)\land \neg (x&lt;y)]\): \(1\in P_a\) and it is not the case that \((1,1)\in P_&lt;\). 
Next we set \(i=2\). 
It then holds that \(M,2,1\models a(y)\land \neg(x&lt;y)]\): \(1\in P_a\) and it is not the case that \((2,1)\in P_&lt;\). 
As is perhaps clear at this point, we really only have to check whether \(M,i,1\models\neg(x&lt;y)\), as we always know that \(M,1\models a(y)\), the first part of the conjunct.
Knowing this, it is clear that when \(i=3\) and \(i=4\), it is also the case that \(M,i,1\models\neg(x&lt;y )\), as neither \((3,1)\) or \((4,1)\) are in \(P_&lt;\). </p>
<p>As we have now checked each of (1,2,3,4) in \(D\), we are finished: for <em>all</em> \(i\in D\),  \(M,i,1\models a(y)\land \neg(x&lt;y)]\), and so \(M,1\models(\forall x)[a(y)\land \neg (x&lt;y)]\).</p>
<h3 id="sentences"><a class="header" href="#sentences">Sentences</a></h3>
<p>An important special case is when a WFF has no free variables---that is, for every variable, there is a quantifier that binds it. 
Such a WFF is called a <strong>sentence</strong>.
This case is important because we can define satisfaction independent of any assignment of variables to elements in \(D\). 
That is, we can talk about whether a model satisfies a sentence directly. </p>
<p><strong>Definition.</strong> (Satisfaction of a sentence). 
For a sentence \(\varphi=(\forall x)[\psi(x)]\), \(M\models\varphi\) iff for all \(i\in D,M,i\models\psi(x)\).</p>
<!--For a sentence \\(\varphi\\), \\(M\models\varphi\\) if for all \\(s:\mathcal{X}\rightarrow D\\), \\(M\models\varphi[s]\\).-->
<p>As an example, consider the WFF
\[\varphi=(\forall x)\big[(\forall y)[\neg(c(x)\land a(y)\land x&lt;y)]\big]\]</p>
<p>First, \(\varphi\) is a sentence because both of its variables \(x\) and \(y\) are bound by a quantifier.
To see how a model can be evaluated for satisfaction of \(\varphi\), take \(M=M(abac)\) from above. 
For this \(M\), \(M\models\varphi\). 
To see why, take any two elements \(i,j\in D\) from the domain of \(M\) and substitute \(i\) for \(x\) and \(j\) for \(y\). 
If you evaluate the formula inside the quantifiers (i.e., \(\neg(c(x)\land a(y)\land x&lt;y)\)), it will return true.
(I leave it to the reader to work out the details themselves.)</p>
<p>To illustrate a model that does <em>not</em> satisfy \(\varphi\), consider \(M=M(abca)\).</p>
<p>\[
\begin{array}{c}
\begin{array}{|c|c|c|c|}\hline
a &amp; b &amp; c &amp; a \\ \hline
\end{array}\\
\begin{array}{cccc}
1 &amp; 2 &amp; 3 &amp; 4 \\
\end{array}
\end{array}
\]</p>
<p>Try evaluating each pair \(i,j\in D\) against \(\varphi\). 
One pair will return false for the internal formula.
Which is it?<sup class="footnote-reference"><a href="#pair">2</a></sup></p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>We have now learned a <strong>syntax</strong> that generates an infinite number of FO WFFs, and a <strong>semantics</strong> that can interpret any one of these WFFs. 
In particular, given a <strong>sentence</strong> with no free variables, we can directly check whether a model satisfies that sentence. 
Next, we will show how this allows a sentence to serve the function of a <em>grammar</em> that describes a formal language. </p>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li>Convince yourself that \((\varphi\lor\psi)\equiv\neg(\neg\varphi\land\neg\psi)\); that is, that the former is <strong>logically equivalent</strong> to the latter.
To do this, use the definition of the semantics to show that the former is true exactly in the cases that the latter is true.
(If you have done a proof before, you can prove this via induction on the two definitions.)</li>
<li>Convince yourself that \((\exists x)[\varphi(x)]\equiv\neg(\forall x)[\neg\varphi(x)]\).</li>
<li>What are some more strings whose models satisfy the sentence \(\varphi\) above?
Some that do not?</li>
</ol>
<hr />
<p><sup class="footnote-reference"><a href="#calc">1</a></sup> There can be more efficient ways to do this, if we know the formula ahead of time. 
But this exact procedure is guaranteed to work for any formula and any model.</p>
<p><sup class="footnote-reference"><a href="#pair">2</a></sup> It fails for \(i=3\) and \(j=4\), as \(i\) is a \(c\) and \(j\) is an \(a\) and \((i,j)\in R_&lt;\). </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-order-logic-and-the-star-free-languages-3"><a class="header" href="#first-order-logic-and-the-star-free-languages-3">First-order Logic and the Star-Free Languages</a></h1>
<h1 id="draft-3"><a class="header" href="#draft-3">[DRAFT]</a></h1>
<h3 id="fo-sentences-as-grammars"><a class="header" href="#fo-sentences-as-grammars">FO sentences as grammars</a></h3>
<p>Recall the following FO sentence from the introduction:</p>
<p>\[\varphi=(\forall x)[a(x)\rightarrow\neg(\exists y)[b(y)\land x&lt;y]]\]</p>
<p>...and the set of strings \(L\) over \(\Sigma=\{a,b,c\}\) such that no \(a\) ever precedes a \(b\), anywhere in the string:</p>
<p>\[ L = \{accca,cccc,bcccb,bbccca,...\}.\]</p>
<p>Take a moment to convince yourself that \(L\) is exactly the set of strings that satisfies \(\varphi\). 
To do this, show yourself that (the models of) a few strings in \(L\) satisfy \(\varphi\), <em>and also that</em> (the models of) a few strings in \(\overline{L}\) <em>do not</em> satisfy \(\varphi\). </p>
<p>Let's look at some more.</p>
<ul>
<li>Write an FO sentence that describes the set of strings that <em>do not</em> end in a \(b\). </li>
<li>Write an FO sentence that describes the set of strings in which \(a\) cannot be followed by another \(a\), unless a \(b\) intervenes. That is, \(caccccac\) is not in the language but \(caccbccca\) is (think the obligatory contour principle-type constraint with blocking).</li>
<li>What about an FO sentence that describes \((ab)^n\)? 
<strong>Hint:</strong> we can define a <strong>successor</strong> relation \(\triangleleft\) from \(&lt;\) using the following equation
\[x\triangleleft y:= x&lt;y\land\neg(\exists z)[x&lt;z\land z&lt;y]\]</li>
<li>What about an FO sentence that describes \(a^nb^n\)?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<script type="text/javascript">
function defaultCopyTextToClipboard(text) {
    var textArea = document.createElement("textarea");
    textArea.value = text;

    // Avoid scrolling to bottom
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";

    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
        var ok = document.execCommand('copy');
        var msg = ok ? 'was ok' : 'failed';
        console.log('Backing copy: Text copy was ' + msg);
    } catch (err) {
        console.error('Backing copy: Unable to copy text', err);
    }

    document.body.removeChild(textArea);
}

function copyToClipboard(text) {
    if (!navigator.clipboard) {
        defaultCopyTextToClipboard(text);
        return;
    }
    navigator.clipboard.writeText(text).then(function() {
        console.log('Text copied to clipboard');
    }, function(err) {
        console.error('Error copying text: ', err);
    });
}

</script>
<style></style>
<div class="bib_div">
<details data-key="rogerspullum11" class=ref>
<summary class=citation>
<a id="rogerspullum11">[rogerspullum11]</a> - James Rogers, Geoffrey Pullum - <a href="https://www.cs.earlham.edu/~jrogers/mol10.pdf" target="_blank"><cite>Aural Pattern Recognition Experiments and The Subregular Hierarchy</cite></a>. - 2011. -
<button onclick="copyToClipboard('\{\{ #cite rogerspullum11 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract"><a class="header" href="#summaryabstract">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="filiot15" class=ref>
<summary class=citation>
<a id="filiot15">[filiot15]</a> - Emmanual Filiot - <cite>Logic-Automata Connections for Transformations</cite>. - 2015. -
<button onclick="copyToClipboard('\{\{ #cite filiot15 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-1"><a class="header" href="#summaryabstract-1">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="heinz10" class=ref>
<summary class=citation>
<a id="heinz10">[heinz10]</a> - Jeffrey Heinz - <a href="http://jeffreyheinz.net/papers/Heinz-2010-LLP.pdf" target="_blank"><cite>Learning Long-Distance Phonotactics</cite></a>. - 2010. -
<button onclick="copyToClipboard('\{\{ #cite heinz10 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-2"><a class="header" href="#summaryabstract-2">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="engelfriethoogeboom01" class=ref>
<summary class=citation>
<a id="engelfriethoogeboom01">[engelfriethoogeboom01]</a> - Joost Engelfriet, Hendrik Jan Hoogeboom - <cite>MSO definable string transductions and two-way finite-state transducers</cite>. - 2001. -
<button onclick="copyToClipboard('\{\{ #cite engelfriethoogeboom01 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-3"><a class="header" href="#summaryabstract-3">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="buchi60" class=ref>
<summary class=citation>
<a id="buchi60">[buchi60]</a> - J. Richard Bϋchi - <a href="https://onlinelibrary.wiley.com/doi/10.1002/malq.19600060105" target="_blank"><cite>Weak second-order arithmetic and finite automata</cite></a>. - 1960. -
<button onclick="copyToClipboard('\{\{ #cite buchi60 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-4"><a class="header" href="#summaryabstract-4">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="mcnaughtonpapert71" class=ref>
<summary class=citation>
<a id="mcnaughtonpapert71">[mcnaughtonpapert71]</a> - Robert McNaughton, Seymour Papert - <cite>Counter-Free Automata</cite>. - 1971. -
<button onclick="copyToClipboard('\{\{ #cite mcnaughtonpapert71 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-5"><a class="header" href="#summaryabstract-5">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="immerman80" class=ref>
<summary class=citation>
<a id="immerman80">[immerman80]</a> - Neil Immerman - <cite>First-order expressibility as a New Complexity Measure</cite>. - 1980. -
<button onclick="copyToClipboard('\{\{ #cite immerman80 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-6"><a class="header" href="#summaryabstract-6">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>
<div class="bib_div">
<details data-key="cook78" class=ref>
<summary class=citation>
<a id="cook78">[cook78]</a> - Eung-Do Cook - <cite>Palatalization and related rules in Sarcee</cite>. - 1978. -
<button onclick="copyToClipboard('\{\{ #cite cook78 \}\}')">Copy citation_key</button>
</summary>
<section class=abstract>
<h1 id="summaryabstract-7"><a class="header" href="#summaryabstract-7">Summary/Abstract</a></h1>
<div>N/A</div>
</section>
</details>
</div>
<br/>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
