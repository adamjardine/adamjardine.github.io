<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>First Order Logic - Formal Language Theory for Linguists</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Abstract Structures</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> The Myhill-Nerode Theorem</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Suffix Substitution Closure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Functions and Tails</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Substitutible Languages</div></li><li class="chapter-item expanded affix "><li class="part-title">Logic</li><li class="chapter-item expanded "><a href="fo.html" class="active"><strong aria-hidden="true">5.</strong> First Order Logic</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Representations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Propositional Logic</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Monadic Second Order Logic</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Interpretations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Boolean Monadic Recursive Schemes</div></li><li class="chapter-item expanded affix "><li class="part-title">Automata</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> ...</div></li><li class="chapter-item expanded affix "><li class="part-title">Learning</li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> ...</div></li><li class="chapter-item expanded affix "><a href="bibliography.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Formal Language Theory for Linguists</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="first-order-logic-and-the-star-free-languages"><a class="header" href="#first-order-logic-and-the-star-free-languages">First-order Logic and the Star-Free Languages</a></h1>
<h1 id="draft"><a class="header" href="#draft">[DRAFT]</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Last time we learned about the difference between computable and uncomputable languages. 
This time, we're going to show how we can compute languages using <strong>first-order logic (FO)</strong>. </p>
<p>Let's start with an actual natural language pattern.
In Sarcee [<a href="bibliography.html#cook78">cook78</a>], [+anterior] sibilants can follow [-anterior] sibilants, but the reverse results in ungrammaticality. 
(Data from [<a href="bibliography.html#cook78">cook78</a>], cited in [<a href="bibliography.html#heinz10">heinz10</a>]. Sibilants are highlighted in bold.)</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>ʃ</strong>ít<strong>ʃ</strong>íd<strong>z</strong>àʔ</td><td>'my duck'</td></tr>
<tr><td>nā<strong>ʃ</strong>ɣát<strong>ʃ</strong></td><td>'I killed them again'</td></tr>
<tr><td>*<strong>s</strong>ít<strong>ʃ</strong>íd<strong>z</strong>àʔ</td><td></td></tr>
</tbody></table>
</div>
<p>In the above example, the [-anterior] [z] follows the [+anterior] [ʃ], but it is impossible for the [+anterior] [ʃ] to follow [s]. </p>
<p>Let's study this abstractly as a formal language.
Let \(L\) be the formal language over \(\Sigma=\{a,b,c\}\) of all strings such that no \(a\) ever precedes a \(b\), anywhere in the string. I.e.,</p>
<p>\[ L = \{accca,cccc,bcccb,bbccca,...\}\]</p>
<p>and </p>
<p>\[ \overline{L} = \{ab,acccb, ccaccccbc, aacccccccccb, .... \}  \]</p>
<p>Thus, \(L\) above distills the precedence-based constraint in Sarcee, replacing [-anterior] consonants with \(a\) and [+anterior] consonants with \(b\) (and everything else with \(c\)). </p>
<p>We can describe \(L\) with the below FO statement that forbids a \(b\) from following an \(a\). </p>
<p>\[(\forall x)[a(x)\rightarrow\neg(\exists y)[b(y)\land x&lt;y]]\]</p>
<p>For now, we'll forgo the formal details and interpret the statement informally. 
The variables \(x\) and \(y\) here range over <em>positions</em> (or <em>indices</em>) in a string. 
Thus, \(a(x)\) is interpreted to mean 'position \(x\) is occupied by the symbol \(a\).' </p>
<p>The entire statement, then, reads as follows:</p>
<blockquote>
<p>For every position \(x\), if \(x\) is an \(a\), then there is no \(y\) such that \(y\) is a \(b\) and \(x\) precedes \(y\).</p>
</blockquote>
<p>This logical statement thus specifies a constraint on strings: for <em>every</em> \(a\) in a string, it cannot precede a \(b\). 
As shown in detail below, this statement is either true or false for every string in \(\Sigma^*\), and there is a procedure for computing this. 
Thus, this logical statement specifies exactly the strings in \(L\): the strings in \(L\) are those for which the statement is true, and the strings <em>not</em> in \(L\) are those for which it is false.</p>
<p>The advantages of using logical statements as grammars are numerous. 
Among them are the following.</p>
<ul>
<li>
<p>We can draw from a rich literature connecting logic and computation [<a href="bibliography.html#buchi60">buchi60</a>],[<a href="bibliography.html#mcnaughtonpapert71">mcnaughtonpapert71</a>],[<a href="bibliography.html#immerman80">immerman80</a>],[<a href="bibliography.html#rogerspullum11">rogerspullum11</a>]. </p>
<!--   * We can thus connect logical grammars to abstract characterizations like \\(k\\)-suffix substitution closure-->
</li>
<li>
<p>We can study patterns over structures besides strings.</p>
</li>
<li>
<p>They allow us to directly connect formal language classes to classes of <em>functions</em>, through the technique of logical interpretations [<a href="bibliography.html#engelfriethoogeboom01">engelfriethoogeboom01</a>],[<a href="bibliography.html#filiot15">filiot15</a>].</p>
</li>
</ul>
<p>There are more, which we will learn about more later. 
For now, we will use FO as a primer for using logical statements as grammars for languages, and discuss how FO is connected to the <strong>star-free (SF)</strong> class of formal languages [<a href="bibliography.html#mcnaughtonpapert71">mcnaughtonpapert71</a>].</p>
<h2 id="string-models"><a class="header" href="#string-models">String models</a></h2>
<p>Before we define our logic, we have to define strings in a bit more detail. 
That is, it is necessary to encode all the information that is necessary to identify a particular string. 
To do this we use <strong>model theory</strong>, the mathematical structure of language. </p>
<p>Continuing to fix our alphabet to \(\Sigma=\{a,b,c\}\), what information do we need to identify a particular string in \(\Sigma^*\) from any other?
The <strong>model</strong> will be a representation of this information.</p>
<p>First, think about the string \(aaaa\) as opposed to \(aaaaaa\). 
What distinguishes the former from the latter, clearly, is that there are four symbols in \(aaaa\) whereas there are six in \(aaaaaa\). 
So we need to distinguish the <em>number</em> of elements in a string. </p>
<p>We do that by establishing a <strong>domain</strong> (also referred to as a <strong>universe</strong>) (D) of elements in the string. 
This is a finite set of objects that represent the elements in our structure. 
By convention, we will use an initial sequence of natural numbers, i.e.
\[D=\{1,2,3,4,...,n\}\]
for some finite \(n\). 
Thus, for example, the domain of the model for \(aaaa\) will be \(\{1,2,3,4\}\) and the domain for the model for \(aaaaaa\) will be \(\{1,2,3,4,5,6\}\). </p>
<p><strong>Note:</strong> While we use numbers, <em>there is no inherent order on these objects</em>. 
We could instead be using symbols like \(\{\square,\triangle,\bigcirc,\diamondsuit\}\). 
But numbers are just easier.</p>
<p>Of course, \(\Sigma^*\) does not only contain strings of all \(a\)s. 
The string \(aaaa\) must also be distinguished from, say \(abaa\). 
So we have to specify the <em>symbols</em> that are associated with elements in the string.
We do this using <strong>relations</strong> on the domain in the model.
A relation \(R\) is a <strong>unary relation</strong> (or <strong>property</strong>) or simply a subset of the domain:
\[R\subseteq D\]</p>
<p>So we can add a unary relation \(R_b\) that indicates which elements are (b)s. 
Thus the model for \(aaaa\) would be 
\[M(aaaa)=\langle D=\{1,2,3,4\}; R_b=\{\}\rangle\]
and the model for \(abaa\) would be 
\[M(abaa)=\langle D=\{1,2,3,4\}; R_b=\{2\}\rangle.\]</p>
<p>We are not yet done though. 
Consider \(abaa\) and \(aaba\). 
These are distinct strings, but their models will be equivalent:
\[M(abaa)=\langle D=\{1,2,3,4\}; R_b=\{2\}\rangle\]
\[M(aaba)=\langle D=\{1,2,3,4\}; R_b=\{3\}\rangle\]
Note that the element in \(R_b\) is different in each of these models, given our numbering scheme, <em>but these elements do not have any inherent order</em>. 
So \(\langle D=\{1,2,3,4\}; R_b=\{3\}\rangle\) is <strong>isomorphic</strong> to \(\langle D=\{1,2,3,4\}; R_b=\{2\}\rangle\). 
That is, <em>given the information available in the model</em>, there is no way to tell the two apart.</p>
<p>So, we add a <strong>binary relation</strong> \(R_&lt;\) that orders the elements in the model.
A binary relation \(R\) consists of pairs of elements in the domain; i.e.
\[R\subseteq D\times D\]</p>
<p>For example, for \(abaa\) we have
\[M(abaa)=\langle D=\{1,2,3,4\}; R_b=\{2\}, R_&lt;=\{(1,2),(2,3),(1,3),(1,4),(2,4),(3,4)\}\rangle\]
and for \(aaba\) we have 
\[M(aaba)=\langle D=\{1,2,3,4\}; R_b=\{3\}, R_&lt;=\{(1,2),(2,3),(1,3),(1,4),(2,4),(3,4)\}\rangle.\]</p>
<p>Now these are different (i.e., non-equivalent) models!
In \(M(abaa)\), the element in \(R_b\) is only preceded by one other element;
in \(M(aaba)\), the element in \(R_b\) is preceded by two. 
So now we have a way to distinguish strings in \(a\)s and \(b\)s, with one relation marking the \(b\)s and an ordering relation on the elements of the domain. </p>
<p>To also capture \(c\)s, we need to add another relation, \(R_c\). 
In fact, for any string signature, it's most straightforward to have a unary relation for each symbol in the alphabet. 
Thus, in this particular case, for any string model we'll need the unary relations \(R_a,R_b,R_c\) and the binary relation \(R_&lt;\). </p>
<p>This set of relations \(R_1,R_2...,R_n\) is called a <strong>signature</strong>. 
We'll use calligraphic capital letters, e.g. \(\mathcal{S}\), to indicate signatures.</p>
<p>The signature we will use to represent strings in an arbitrary finite alphabet \(\Sigma=\{\sigma_1,\sigma_2,...,\sigma_n\}\) is as follows.</p>
<p>\[\mathcal{S}^&lt;=\{R_{\sigma_1},R_{\sigma_2},...,R_{\sigma_n},R_&lt;\}\]</p>
<p>To recap, a (finite) <strong>model</strong> is a mathematical object that lets us describe other objects. 
Formally, it is a tuple consisting of a set of elements or <strong>domain</strong> (or <strong>universe</strong>) \(D\) and a series of relations \(R_1,R_2,..., R_n\) on the domain. </p>
<p>\[\langle D; R_1, R_2, ..., R_n\rangle\]</p>
<p>The name of a particular set of relations that we use to model some set of structures is a <strong>signature</strong>. </p>
<h2 id="first-order-logic"><a class="header" href="#first-order-logic">First order logic</a></h2>
<p>Given a signature, we can define a FO logic over that signature. 
To build such a logic and define how it can be interpreted over models in the signature, we need to define the <strong>syntax</strong> and <strong>semantics</strong> of FO.
Defining this precisely tells us not only the range of grammars we can write, but also how these grammars compute languages.</p>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>The syntax defines the range of statements we can write.</p>
<p>First, statements in FO choose from a set of <strong>variables</strong> \(\mathcal{X}=\{x,y,z,...,x_1,x_2,...\}\). </p>
<p>Additionally, for each relation in the signature, we have a set of <strong>atomic formulas</strong> that correspond to the relations in our model (plus equality).</p>
<p><strong>Definition.</strong> (Atomic formulas)</p>
<ol>
<li>For any two variables \(x\) and \(y\), \(x=y\) is an atomic formula. </li>
<li>For any two variables \(x\) and \(y\), \(x&lt;y\) is an atomic formula.</li>
<li>For any variable \(x\) and any unary relation \(R_\sigma\in\mathcal{S}\), \(\sigma(x)\) is an atomic formula.</li>
</ol>
<p>Atomic formulas, as their name suggests, define the basic properties in the model to which the logic refers. 
Given our running example for \(\Sigma={a,b,c}\), some atomic formulas are \(a(x)\), \(b(z)\), \(x=y\), \(y&lt;z\), etc.</p>
<p>The set of <strong>well-formed formulas (WFFs)</strong> in FO is then built out of atomic formulas connected by the logical connectives 
\(\neg\) and \(\lor\) and the quantifier \(\forall\). </p>
<!--\\(\neg, \land, \lor, \rightarrow\\) and the quantifiers \\(\forall, \exists\\).-->
<p><strong>Definition.</strong> (Well-formed formulas) </p>
<ol>
<li>If \(\varphi\) is an atomic formula, then \(\varphi\) is a WFF </li>
<li>If \(\varphi\) is a WFF, then \((\neg\varphi)\) is a WFF <!--* If \\(\varphi\\) and \\(\psi\\) are WFFs, then \\((\varphi\land\psi)\\) are WFFs--></li>
<li>If \(\varphi\) and \(\psi\) are WFFs, then \((\varphi\lor\psi)\) are WFFs <!--* If \\(\varphi\\) and \\(\psi\\) are WFFs, then \\((\varphi\rightarrow\psi)\\) are WFFs--></li>
<li>If \(\varphi\) is a WFF for which \(x\) is a free variable, then \((\forall x)[\varphi]\) is a WFF <!--* If \\(\varphi\\) is a WFF for which \\(x\\) is a free variable, then \\((\exists x)[\varphi]\\) is a WFF--></li>
</ol>
<p>A <strong>free variable</strong> in an formula \(\varphi\) is a variable \(x\) such that \(...x...\) appears in \(\varphi\) without being preceded by \((\forall x)\) or \((\exists x)\) (i.e., it's not <strong>bound</strong> by a quantifier).</p>
<p>Note that this definition is <em>recursive</em>: the definition of WFF itself refers to WFFs. 
Thus, we can write an infinite number of WFFs by recursively applying the rules above.
For example, \((\neg a(x))\) is built by starting with the atomic formula \(a(x)\) and plugging that in as \(\phi\) for rule (2.) in the definition of WFFs. </p>
<blockquote>
<p>Take a moment to convince yourself of how this works by deriving the WFFs \(((\neg a(x))\lor b(x))\) and \((\forall x)[(b(x)\lor(\neg(c(x))))\).</p>
</blockquote>
<p><strong>Some notational sugar.</strong>
The parentheses in the above definition make the composition of a WFF explicit, but they are often removed for readability when there is no danger of ambiguity.
So, for example, \(((\neg a(x))\lor b(x))\) can be rewritten as \(\neg a(x)\lor b(x)\). </p>
<p>Finally, the other common logical connectives \(\rightarrow\) and \(\land\) and the quantifier \(\exists\) can be derived from the syntax we've already defined. 
Namely, </p>
<ul>
<li>\(\varphi\rightarrow\psi := \neg\varphi\lor\psi\)</li>
<li>\(\varphi\land\psi := \neg(\neg\varphi\lor\neg\psi)\)</li>
<li>\((\exists x)[\varphi] := \neg(\forall x)[\neg\varphi]\)</li>
</ul>
<p>...where the notation '\(:=\)' means something like 'can be re-written as'. </p>
<blockquote>
<p>Take a minute apply the above to construct our original example of \((\forall x)[a(x)\rightarrow\neg(\exists y)[b(y)\land x&lt;y]]\). </p>
</blockquote>
<h3 id="semantics"><a class="header" href="#semantics">Semantics</a></h3>
<p>So far our FO WFFs are just strings of meaningless symbols. 
We have to define the semantics of our WFFs; that is, when a WFF is true in a model.</p>
<p>For a model \(M\), take a function \(s:\mathcal{X}\rightarrow D\) that maps the set of possible FO variables to positions in \(M\)'s domain \(D\). 
We can then say that the model <strong>satisfies</strong> a WFF \(\varphi\) given this mapping, written </p>
<p>\[M\models\varphi[s]\]</p>
<p>under the following conditions:</p>
<p><strong>Definition.</strong> (Semantics of FO)</p>
<p>a. \(M\models x=y[s]\)   iff   \(s(x)=s(y)\)</p>
<p>b. \(M\models x&lt;y[s]\)   iff   \(s(x)&lt;s(y)\)</p>
<p>c. \(M\models \sigma(x)[s]\)   iff   \(s(x)\in P_\sigma\)</p>
<p>d. \(M\models (\neg\varphi)[s]\)   iff \(M\not\models\varphi[s]\)</p>
<p>e. \(M\models (\varphi\land\psi)[s]\)  iff \(M\models\varphi[s]\) and \(M\models\psi[s]\)</p>
<p>f. \(M\models (\varphi\lor\psi)[s]\) iff \(M\models\varphi[s]\) or \(M\models\psi[s]\)</p>
<p>g. \(M\models (\varphi\rightarrow\psi)[s]\) iff \(M\models(\neg\varphi\lor\psi)[s]\)</p>
<p>h. \(M\models (\forall x)[\varphi][s]\) iff for all \(d\in D\), \(M\models \varphi[s; x\mapsto d]\)</p>
<p>i. \(M\models (\exists x)[\varphi][s]\) iff for some \(d\in D\), \(M\models \varphi[s; x\mapsto d]\)</p>
<p>A WFF with no free variables is called a <strong>sentence</strong>.
If \(\varphi\) is a sentence, we can define satisfaction independent of such a function.</p>
<p><strong>Definition</strong> (Satisfaction of a sentence). \(M\models\varphi\) if for all \(s:\mathcal{X}\rightarrow D\), \(M\models\varphi[s]\).</p>
<h3 id="fo-sentences-as-grammars"><a class="header" href="#fo-sentences-as-grammars">FO sentences as grammars</a></h3>
<p>Take a moment to convince yourself that \(L\) is exactly the set of strings that satisfies the sentence \((\forall x)[a(x)\rightarrow\neg(\exists y)[b(y)\land x&lt;y]]\).</p>
<p>Let's look at some more.</p>
<ul>
<li>Write an FO sentence that describes the set of strings that <em>do not</em> end in a \(b\). </li>
<li>Write an FO sentence that describes the set of strings in which \(a\) cannot be followed by another \(a\), unless a \(b\) intervenes. That is, \(caccccac\) is not in the language but \(caccbccca\) is (think the obligatory contour principle-type constraint with blocking).</li>
<li>What about an FO sentence that describes \((ab)^n\)? 
<strong>Hint:</strong> we can define a <strong>successor</strong> relation \(\triangleleft\) from \(&lt;\) using the following equation
\[x\triangleleft y:= x&lt;y\land\neg(\exists z)[x&lt;z\land z&lt;y]\]</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="overview.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="bibliography.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="overview.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="bibliography.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
