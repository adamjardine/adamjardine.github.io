<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Syntax and semantics - Formal Language Theory for Linguists</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Abstract Structures</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> The Myhill-Nerode Theorem</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Suffix Substitution Closure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Functions and Tails</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Substitutible Languages</div></li><li class="chapter-item expanded affix "><li class="part-title">Logic</li><li class="chapter-item expanded "><a href="fo-intro.html"><strong aria-hidden="true">5.</strong> First Order Logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fo-models.html"><strong aria-hidden="true">5.1.</strong> String models</a></li><li class="chapter-item expanded "><a href="fo-synsem.html" class="active"><strong aria-hidden="true">5.2.</strong> Syntax and semantics</a></li><li class="chapter-item expanded "><a href="fo-grammars.html"><strong aria-hidden="true">5.3.</strong> Formulas as grammars</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Representations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Propositional Logic</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Monadic Second Order Logic</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Interpretations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Boolean Monadic Recursive Schemes</div></li><li class="chapter-item expanded affix "><li class="part-title">Automata</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> ...</div></li><li class="chapter-item expanded affix "><li class="part-title">Learning</li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> ...</div></li><li class="chapter-item expanded affix "><a href="bibliography.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Formal Language Theory for Linguists</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="first-order-logic-and-the-star-free-languages"><a class="header" href="#first-order-logic-and-the-star-free-languages">First-order Logic and the Star-Free Languages</a></h1>
<h1 id="draft"><a class="header" href="#draft">[DRAFT]</a></h1>
<h2 id="the-syntax-and-semantics-of-first-order-logic"><a class="header" href="#the-syntax-and-semantics-of-first-order-logic">The syntax and semantics of first order logic</a></h2>
<p>Given a signature, we can define a FO logic over that signature. 
To build such a logic and define how it can be interpreted over models in the signature, we need to define the <strong>syntax</strong> and <strong>semantics</strong> of FO.
Defining this precisely tells us not only the range of grammars we can write, but also how these grammars compute languages.</p>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>The syntax defines the range of statements we can write.</p>
<p>First, statements in FO choose from a set of <strong>variables</strong> \(\mathcal{X}=\{x,y,z,...,x_1,x_2,...\}\). </p>
<p>Additionally, for each relation in the signature, we have a set of <strong>atomic formulas</strong> that correspond to the relations in our model (plus equality).</p>
<p><strong>Definition.</strong> (Atomic formulas)</p>
<ol>
<li>For any two variables \(x\) and \(y\), \(x=y\) is an atomic formula. </li>
<li>For any two variables \(x\) and \(y\), \(x&lt;y\) is an atomic formula.</li>
<li>For any variable \(x\) and any unary relation \(R_\sigma\in\mathcal{S}\), \(\sigma(x)\) is an atomic formula.</li>
</ol>
<p>Atomic formulas, as their name suggests, define the basic properties in the model to which the logic refers. 
Given our running example for \(\Sigma={a,b,c}\), some atomic formulas are \(a(x)\), \(b(z)\), \(x=y\), \(y&lt;z\), etc.</p>
<p>The set of <strong>well-formed formulas (WFFs)</strong> in FO is then built out of atomic formulas connected by the logical connectives 
\(\neg\) and \(\lor\) and the quantifier \(\forall\). </p>
<!--\\(\neg, \land, \lor, \rightarrow\\) and the quantifiers \\(\forall, \exists\\).-->
<p><strong>Definition.</strong> (Well-formed formulas) </p>
<ol>
<li>If \(\varphi\) is an atomic formula, then \(\varphi\) is a WFF </li>
<li>If \(\varphi\) is a WFF, then \((\neg\varphi)\) is a WFF <!--* If \\(\varphi\\) and \\(\psi\\) are WFFs, then \\((\varphi\land\psi)\\) are WFFs--></li>
<li>If \(\varphi\) and \(\psi\) are WFFs, then \((\varphi\lor\psi)\) are WFFs <!--* If \\(\varphi\\) and \\(\psi\\) are WFFs, then \\((\varphi\rightarrow\psi)\\) are WFFs--></li>
<li>If \(\varphi\) is a WFF for which \(x\) is a free variable, then \((\forall x)[\varphi]\) is a WFF <!--* If \\(\varphi\\) is a WFF for which \\(x\\) is a free variable, then \\((\exists x)[\varphi]\\) is a WFF--></li>
</ol>
<p>A <strong>free variable</strong> in an formula \(\varphi\) is a variable \(x\) such that \(...x...\) appears in \(\varphi\) without being preceded by \((\forall x)\) or \((\exists x)\) (i.e., it's not <strong>bound</strong> by a quantifier).</p>
<p>Note that this definition is <em>recursive</em>: the definition of WFF itself refers to WFFs. 
Thus, we can write an infinite number of WFFs by recursively applying the rules above.
For example, \((\neg a(x))\) is built by starting with the atomic formula \(a(x)\) and plugging that in as \(\phi\) for rule (2.) in the definition of WFFs. </p>
<blockquote>
<p>Take a moment to convince yourself of how this works by deriving the WFFs \(((\neg a(x))\lor b(x))\) and \((\forall x)[(b(x)\lor(\neg(c(x))))\).</p>
</blockquote>
<p><strong>Some notational sugar.</strong>
The parentheses in the above definition make the composition of a WFF explicit, but they are often removed for readability when there is no danger of ambiguity.
So, for example, \(((\neg a(x))\lor b(x))\) can be rewritten as \(\neg a(x)\lor b(x)\). </p>
<p>Finally, the other common logical connectives \(\rightarrow\) and \(\land\) and the quantifier \(\exists\) can be derived from the syntax we've already defined. 
Namely, </p>
<ul>
<li>\(\varphi\rightarrow\psi := \neg\varphi\lor\psi\)</li>
<li>\(\varphi\land\psi := \neg(\neg\varphi\lor\neg\psi)\)</li>
<li>\((\exists x)[\varphi] := \neg(\forall x)[\neg\varphi]\)</li>
</ul>
<p>...where the notation '\(:=\)' means something like 'can be re-written as'. </p>
<blockquote>
<p>Take a minute apply the above to construct our original example of \((\forall x)[a(x)\rightarrow\neg(\exists y)[b(y)\land x&lt;y]]\). </p>
</blockquote>
<h3 id="semantics"><a class="header" href="#semantics">Semantics</a></h3>
<p>So far our FO WFFs are just strings of meaningless symbols. 
We have to define the semantics of our WFFs; that is, when a WFF is true in a model.
We will do this <em>recursively</em>, following closely the definition above of the syntax of FO logic. 
In this way, for every sentence we can construct using our syntax, our semantics guarantees an interpretation for it.</p>
<p>Because this is a <em>first-order</em> logic, the variables \(x,y,z,\) etc. range over elements of the domain (i.e., positions in the string).
Satisfaction is then dependent on how variables are assigned to positions into the string. 
As such, our notation for satisfaction must take into account this dependency.</p>
<p>Thus, satisfaction will be defined specifying the model \(M\) and some series \(i_1,i_2,...,i_k\) of \(k\) elements in \(D\).
Accordingly, below \(\varphi(x_1,x_2,...,x_k)\) refers to a WFF with exactly \(k\) free variables \(x_1,x_2,...,x_k\). 
Essentially, we are going to plug each \(i_j\) into each variable \(x_j\).</p>
<!--For a model \\(M\\), take a function \\(s:\mathcal{X}\rightarrow D\\) that maps the set of possible FO variables to positions in \\(M\\)'s domain \\(D\\). 
We can then say that the model **satisfies** a WFF \\(\varphi\\) given this mapping, written -->
<p><strong>Definition.</strong> (Satisfaction of well-formed formulas)</p>
<ol>
<li>a. \(M,i\models \sigma(x)\)   iff   \(i\in R_\sigma\)<br />
b. \(M,i,j\models (x&lt;y)\) iff \((i,j)\in R_&lt;\)<br />
c. \(M,i,j\models (x=y)\) iff \(i=j\) (that is, \(i\) and \(j\) are the same element in \(D\).)</li>
<li>\(M,i_1,i_2...,i_k\models \neg\varphi(x_1,x_2...,x_k)\) iff \(M,i_1,i_2,...,i_k\not\models \varphi(x_1,x_2...,x_k)\) (that is, \(M,i_1,i_2,...,i_k\) <em>does not</em> satisfy \(\varphi(x_1,x_2,...,x_k)\)). </li>
<li>\(M,i_1,i_2,...,i_k,j_1,j_2,...,j_\ell\models \varphi(x_1,x_2,...,x_k)\land\psi(y_1,y_2,...,y_\ell)\) iff \(M,i_1,...,i_k\models \varphi(x_1,x_2,...,x_k)\) and \(M,j_1,j_2,...,j_k\models \psi(y_1,y_2,...,y_\ell).\)</li>
<li>\(M,i_1,...,i_k\models (\forall x)[\varphi(x,y_1,y_2,...,y_k)]\) iff for all \(i\in D\), \(M,i,i_1,...,i_k\models\varphi(x,y_1,...,y_k).\)</li>
</ol>
<p>This is a lot, so let us go through each. 
To illustrate, we'll use \(M=M(abac)\), depicted graphically below.</p>
<p>\[
\begin{array}{c}
\begin{array}{|c|c|c|c|}\hline
a &amp; b &amp; a &amp; c \\ \hline
\end{array}\\
\begin{array}{cccc}
1 &amp; 2 &amp; 3 &amp; 4 \\
\end{array}
\end{array}
\]</p>
<p>First, notice that each part of the definition matches with the definition of the syntax of well-formed formulas above.
Thus, for example, part (1) of the definition of the semantics defines the semantics for atomic formulas (i.e., from part (1) of the definition of the syntax).</p>
<p>So if our WFF is simply \(a(x)\), then \(M,1\models a(x)\) because \(1\in R_a\) in \(M\); conversely, \(M,2\not\models a(x)\) because \(2\not\in R_a\) in \(M\).
Similarly, \(M,1,2,3\models(\neg b(x))\land (y&lt;z)\) because \(M,1\models\neg b(x)\) (because \(1\not\in R_b\) and thus \(M,1\not\models b(x)\)) and \(M,2,3\models y&lt;z\) (because \((2,3)\in R_&lt;\)).</p>
<p>Part (4) of the definition, with the quantifier, is a bit different.
Say we have a WFF \((\forall x)[a(y)\land y&lt;x]\). 
Satisfaction here only requires specifying one element in the domain, specifically that which will correspond to \(y\), as \(x\) is bound by a quantifier. 
So let us check whether \(M,1\models(\forall x)[a(y)\land \neg( y&lt;x )]\). </p>
<p>By the definition, \(M,1\models(\forall x)[a(y)\land \neg (x&lt;y)]\) only in the case that for <em>all</em> \(i\in D\),  \(M,i,1\models a(y)\land \neg x&lt;y]\). 
In other words, no matter what element we assign \(x\) to, satisfaction goes through. 
One sure way to calculate this is via brute force, i.e. checking each element in \(D\) to make sure satisfaction holds in every case.<sup class="footnote-reference"><a href="#calc">1</a></sup>
So first we set \(i=1\). 
It holds that \(M,1,1\models a(y)\land \neg (x&lt;y)]\): \(1\in P_a\) and it is not the case that \((1,1)\in P_&lt;\). 
Next we set \(i=2\). 
It then holds that \(M,2,1\models a(y)\land \neg(x&lt;y)]\): \(1\in P_a\) and it is not the case that \((2,1)\in P_&lt;\). 
As is perhaps clear at this point, we really only have to check whether \(M,i,1\models\neg(x&lt;y)\), as we always know that \(M,1\models a(y)\), the first part of the conjunct.
Knowing this, it is clear that when \(i=3\) and \(i=4\), it is also the case that \(M,i,1\models\neg(x&lt;y )\), as neither \((3,1)\) or \((4,1)\) are in \(P_&lt;\). </p>
<p>As we have now checked each of (1,2,3,4) in \(D\), we are finished: for <em>all</em> \(i\in D\),  \(M,i,1\models a(y)\land \neg(x&lt;y)]\), and so \(M,1\models(\forall x)[a(y)\land \neg (x&lt;y)]\).</p>
<h3 id="sentences"><a class="header" href="#sentences">Sentences</a></h3>
<p>An important special case is when a WFF has no free variables---that is, for every variable, there is a quantifier that binds it. 
Such a WFF is called a <strong>sentence</strong>.
This case is important because we can define satisfaction independent of any assignment of variables to elements in \(D\). 
That is, we can talk about whether a model satisfies a sentence directly. </p>
<p><strong>Definition.</strong> (Satisfaction of a sentence). 
For a sentence \(\varphi=(\forall x)[\psi(x)]\), \(M\models\varphi\) iff for all \(i\in D,M,i\models\psi(x)\).</p>
<!--For a sentence \\(\varphi\\), \\(M\models\varphi\\) if for all \\(s:\mathcal{X}\rightarrow D\\), \\(M\models\varphi[s]\\).-->
<p>As an example, consider the WFF
\[\varphi=(\forall x)\big[(\forall y)[\neg(c(x)\land a(y)\land x&lt;y)]\big]\]</p>
<p>First, \(\varphi\) is a sentence because both of its variables \(x\) and \(y\) are bound by a quantifier.
To see how a model can be evaluated for satisfaction of \(\varphi\), take \(M=M(abac)\) from above. 
For this \(M\), \(M\models\varphi\). 
To see why, take any two elements \(i,j\in D\) from the domain of \(M\) and substitute \(i\) for \(x\) and \(j\) for \(y\). 
If you evaluate the formula inside the quantifiers (i.e., \(\neg(c(x)\land a(y)\land x&lt;y)\)), it will return true.
(I leave it to the reader to work out the details themselves.)</p>
<p>To illustrate a model that does <em>not</em> satisfy \(\varphi\), consider \(M=M(abca)\).</p>
<p>\[
\begin{array}{c}
\begin{array}{|c|c|c|c|}\hline
a &amp; b &amp; c &amp; a \\ \hline
\end{array}\\
\begin{array}{cccc}
1 &amp; 2 &amp; 3 &amp; 4 \\
\end{array}
\end{array}
\]</p>
<p>Try evaluating each pair \(i,j\in D\) against \(\varphi\). 
One pair will return false for the internal formula.
Which is it?<sup class="footnote-reference"><a href="#pair">2</a></sup></p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>We have now learned a <strong>syntax</strong> that generates an infinite number of FO WFFs, and a <strong>semantics</strong> that can interpret any one of these WFFs. 
In particular, given a <strong>sentence</strong> with no free variables, we can directly check whether a model satisfies that sentence. 
Next, we will show how this allows a sentence to serve the function of a <em>grammar</em> that describes a formal language. </p>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li>Convince yourself that \((\varphi\lor\psi)\equiv\neg(\neg\varphi\land\neg\psi)\); that is, that the former is <strong>logically equivalent</strong> to the latter.
To do this, use the definition of the semantics to show that the former is true exactly in the cases that the latter is true.
(If you have done a proof before, you can prove this via induction on the two definitions.)</li>
<li>Convince yourself that \((\exists x)[\varphi(x)]\equiv\neg(\forall x)[\neg\varphi(x)]\).</li>
<li>What are some more strings whose models satisfy the sentence \(\varphi\) above?
Some that do not?</li>
</ol>
<hr />
<p><sup class="footnote-reference"><a href="#calc">1</a></sup> There can be more efficient ways to do this, if we know the formula ahead of time. 
But this exact procedure is guaranteed to work for any formula and any model.</p>
<p><sup class="footnote-reference"><a href="#pair">2</a></sup> It fails for \(i=3\) and \(j=4\), as \(i\) is a \(c\) and \(j\) is an \(a\) and \((i,j)\in R_&lt;\). </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="fo-models.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="fo-grammars.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="fo-models.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="fo-grammars.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
